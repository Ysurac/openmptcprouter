From 964f624954b5e4ea83a4f05a57d79a6af6836d13 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=9D=8E=E5=9B=BD?= <uxgood.org@gmail.com>
Date: Thu, 4 Apr 2019 02:40:15 +0000
Subject: [PATCH 1/8] firmware-utils: ptgen: add GPT support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Add GPT support to ptgen, so we can generate EFI bootable images.

Introduced two options:
    -g        generate GPT partition table
    -G GUID   use GUID for disk and increase last bit for all partitions

We drop The alternate partition table to reduce size, This may cause
problems when generate vmdk images or vdi images. We must pad enough
sectors when generate these images.

Signed-off-by: 李国 <uxgood.org@gmail.com>
---
 tools/firmware-utils/Makefile    |   2 +-
 tools/firmware-utils/src/ptgen.c | 337 ++++++++++++++++++++++++++++---
 2 files changed, 314 insertions(+), 25 deletions(-)

diff --git a/tools/firmware-utils/Makefile b/tools/firmware-utils/Makefile
index 97c89eec279..561d6d868fe 100644
--- a/tools/firmware-utils/Makefile
+++ b/tools/firmware-utils/Makefile
@@ -32,7 +32,7 @@ define Host/Compile
 	$(call cc,dgfirmware)
 	$(call cc,mksenaofw md5, -Wall --std=gnu99)
 	$(call cc,trx2usr)
-	$(call cc,ptgen)
+	$(call cc,ptgen cyg_crc32)
 	$(call cc,srec2bin)
 	$(call cc,mkmylofw)
 	$(call cc,mkcsysimg)
diff --git a/tools/firmware-utils/src/ptgen.c b/tools/firmware-utils/src/ptgen.c
index 0192bb65e51..caee0f94190 100644
--- a/tools/firmware-utils/src/ptgen.c
+++ b/tools/firmware-utils/src/ptgen.c
@@ -31,15 +31,62 @@
 #include <ctype.h>
 #include <fcntl.h>
 #include <stdint.h>
+#include <linux/uuid.h>
+#include "cyg_crc.h"
 
 #if __BYTE_ORDER == __BIG_ENDIAN
+#define cpu_to_le16(x) bswap_16(x)
 #define cpu_to_le32(x) bswap_32(x)
+#define cpu_to_le64(x) bswap_64(x)
 #elif __BYTE_ORDER == __LITTLE_ENDIAN
+#define cpu_to_le16(x) (x)
 #define cpu_to_le32(x) (x)
+#define cpu_to_le64(x) (x)
 #else
 #error unknown endianness!
 #endif
 
+#define swap(a, b) \
+	do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)
+
+#ifndef GUID_INIT
+typedef uuid_le guid_t;
+#define GUID_INIT(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7)      \
+	UUID_LE(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7)
+#endif
+
+#define GUID_STRING_LENGTH      36
+
+#define GPT_SIGNATURE 0x5452415020494645ULL
+#define GPT_REVISION 0x00010000
+
+#define GUID_PARTITION_SYSTEM \
+	GUID_INIT( 0xC12A7328, 0xF81F, 0x11d2, \
+			0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B)
+
+#define GUID_PARTITION_BASIC_DATA \
+	GUID_INIT( 0xEBD0A0A2, 0xB9E5, 0x4433, \
+			0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7)
+
+#define GUID_PARTITION_BIOS_BOOT \
+	GUID_INIT( 0x21686148, 0x6449, 0x6E6F, \
+			0x74, 0x4E, 0x65, 0x65, 0x64, 0x45, 0x46, 0x49)
+
+#define GPT_HEADER_SIZE         92
+#define GPT_ENTRY_SIZE          128
+#define GPT_ENTRY_MAX           128
+#define GPT_ENTRY_NAME_SIZE     72
+
+#define GPT_HEADER_SECTOR       1
+#define GPT_FIRST_ENTRY_SECTOR  2
+
+#define MBR_ENTRY_MAX           4
+#define MBR_DISK_SIGNATURE_OFFSET  440
+#define MBR_PARTITION_ENTRY_OFFSET 446
+#define MBR_BOOT_SIGNATURE_OFFSET  510
+
+#define DISK_SECTOR_SIZE        512
+
 /* Partition table entry */
 struct pte {
 	uint8_t active;
@@ -55,13 +102,43 @@ struct partinfo {
 	int type;
 };
 
+/* GPT Partition table header */
+struct gpth {
+	uint64_t signature;
+	uint32_t revision;
+	uint32_t size;
+	uint32_t crc32;
+	uint32_t reserved;
+	uint64_t self;
+	uint64_t alternate;
+	uint64_t first_usable;
+	uint64_t last_usable;
+	guid_t disk_guid;
+	uint64_t first_entry;
+	uint32_t entry_num;
+	uint32_t entry_size;
+	uint32_t entry_crc32;
+} __attribute__((packed));
+
+/* GPT Partition table entry */
+struct gpte {
+	guid_t type;
+	guid_t guid;
+	uint64_t start;
+	uint64_t end;
+	uint64_t attr;
+	uint16_t name[GPT_ENTRY_NAME_SIZE / sizeof(uint16_t)];
+} __attribute__((packed));
+
+
 int verbose = 0;
 int active = 1;
 int heads = -1;
 int sectors = -1;
 int kb_align = 0;
 bool ignore_null_sized_partition = false;
-struct partinfo parts[4];
+bool use_guid_partition_table = false;
+struct partinfo parts[GPT_ENTRY_MAX];
 char *filename = NULL;
 
 
@@ -91,7 +168,7 @@ static long to_kbytes(const char *string)
 		end++;
 
 	if (*end) {
-		fprintf(stderr, "garbage after end of number\n");
+		fputs("garbage after end of number\n", stderr);
 		return 0;
 	}
 
@@ -132,20 +209,73 @@ static inline unsigned long round_to_kb(long sect) {
         return ((sect - 1) / kb_align + 1) * kb_align;
 }
 
+/* Compute a CRC for guid partition table */
+static inline unsigned long gpt_crc32(void *buf, unsigned long len)
+{
+	return cyg_crc32_accumulate(~0L, buf, len) ^ ~0L;
+}
+
+/* Parse a guid string to guid_t struct */
+static inline int guid_parse(char *buf, guid_t *guid)
+{
+	char b[4] = {0};
+	char *p = buf;
+	unsigned i = 0;
+	if (strnlen(buf, GUID_STRING_LENGTH) != GUID_STRING_LENGTH)
+		return -1;
+	for (i = 0; i < sizeof(guid_t); i++) {
+		if (*p == '-')
+			p++;
+		if (*p == '\0')
+			return -1;
+		memcpy(b, p, 2);
+		guid->b[i] = strtol(b, 0, 16);
+		p += 2;
+	}
+	swap(guid->b[0], guid->b[3]);
+	swap(guid->b[1], guid->b[2]);
+	swap(guid->b[4], guid->b[5]);
+	swap(guid->b[6], guid->b[7]);
+	return 0;
+}
+
+/* init an utf-16 string from utf-8 string */
+static inline void init_utf16(char *str, uint16_t *buf, unsigned bufsize)
+{
+	unsigned i, n = 0;
+	for (i = 0; i < bufsize; i++) {
+		if (str[n] == 0x00) {
+			buf[i] = 0x00;
+			return ;
+		} else if ((str[n] & 0x80) == 0x00) {//0xxxxxxx
+			buf[i] = cpu_to_le16(str[n++]);
+		} else if ((str[n] & 0xE0) == 0xC0) {//110xxxxx
+			buf[i] = cpu_to_le16((str[n] & 0x1F) << 6 | str[n + 1] & 0x3F);
+			n += 2;
+		} else if ((str[n] & 0xF0) == 0xE0) {//1110xxxx
+			buf[i] = cpu_to_le16((str[n] & 0x0F) << 12 | (str[n + 1] & 0x3F) << 6 | str[n + 2] & 0x3F);
+			n += 3;
+		} else {
+			buf[i] = cpu_to_le16('?');
+			n++;
+		}
+	}
+}
+
 /* check the partition sizes and write the partition table */
 static int gen_ptable(uint32_t signature, int nr)
 {
-	struct pte pte[4];
-	unsigned long sect = 0;
-	int i, fd, ret = -1, start, len;
+	struct pte pte[MBR_ENTRY_MAX];
+	unsigned long start, len, sect = 0;
+	int i, fd, ret = -1;
 
-	memset(pte, 0, sizeof(struct pte) * 4);
+	memset(pte, 0, sizeof(struct pte) * MBR_ENTRY_MAX);
 	for (i = 0; i < nr; i++) {
 		if (!parts[i].size) {
 			if (ignore_null_sized_partition)
 				continue;
 			fprintf(stderr, "Invalid size in partition %d!\n", i);
-			return -1;
+			return ret;
 		}
 
 		pte[i].active = ((i + 1) == active) ? 0x80 : 0;
@@ -165,30 +295,34 @@ static int gen_ptable(uint32_t signature, int nr)
 		to_chs(start + len - 1, pte[i].chs_end);
 
 		if (verbose)
-			fprintf(stderr, "Partition %d: start=%ld, end=%ld, size=%ld\n", i, (long)start * 512, ((long)start + (long)len) * 512, (long)len * 512);
-		printf("%ld\n", (long)start * 512);
-		printf("%ld\n", (long)len * 512);
+			fprintf(stderr, "Partition %d: start=%ld, end=%ld, size=%ld\n",
+					i,
+					(long)start * DISK_SECTOR_SIZE,
+					(long)(start + len) * DISK_SECTOR_SIZE,
+					(long)len * DISK_SECTOR_SIZE);
+		printf("%ld\n", (long)start * DISK_SECTOR_SIZE);
+		printf("%ld\n", (long)len * DISK_SECTOR_SIZE);
 	}
 
 	if ((fd = open(filename, O_WRONLY|O_CREAT|O_TRUNC, 0644)) < 0) {
 		fprintf(stderr, "Can't open output file '%s'\n",filename);
-		return -1;
+		return ret;
 	}
 
-	lseek(fd, 440, SEEK_SET);
+	lseek(fd, MBR_DISK_SIGNATURE_OFFSET, SEEK_SET);
 	if (write(fd, &signature, sizeof(signature)) != sizeof(signature)) {
-		fprintf(stderr, "write failed.\n");
+		fputs("write failed.\n", stderr);
 		goto fail;
 	}
 
-	lseek(fd, 446, SEEK_SET);
-	if (write(fd, pte, sizeof(struct pte) * 4) != sizeof(struct pte) * 4) {
-		fprintf(stderr, "write failed.\n");
+	lseek(fd, MBR_PARTITION_ENTRY_OFFSET, SEEK_SET);
+	if (write(fd, pte, sizeof(struct pte) * MBR_ENTRY_MAX) != sizeof(struct pte) * MBR_ENTRY_MAX) {
+		fputs("write failed.\n", stderr);
 		goto fail;
 	}
-	lseek(fd, 510, SEEK_SET);
+	lseek(fd, MBR_BOOT_SIGNATURE_OFFSET, SEEK_SET);
 	if (write(fd, "\x55\xaa", 2) != 2) {
-		fprintf(stderr, "write failed.\n");
+		fputs("write failed.\n", stderr);
 		goto fail;
 	}
 
@@ -198,20 +332,162 @@ static int gen_ptable(uint32_t signature, int nr)
 	return ret;
 }
 
+/* check the partition sizes and write the guid partition table */
+static int gen_gptable(uint32_t signature, guid_t guid, unsigned nr)
+{
+	struct pte pte;
+	struct gpth gpth = {
+		.signature = cpu_to_le64(GPT_SIGNATURE),
+		.revision = cpu_to_le32(GPT_REVISION),
+		.size = cpu_to_le32(GPT_HEADER_SIZE),
+		.self = cpu_to_le64(GPT_HEADER_SECTOR),
+		.first_usable = cpu_to_le64(GPT_FIRST_ENTRY_SECTOR + GPT_ENTRY_SIZE * GPT_ENTRY_MAX / DISK_SECTOR_SIZE),
+		.first_entry = cpu_to_le64(GPT_FIRST_ENTRY_SECTOR),
+		.disk_guid = guid,
+		.entry_num = cpu_to_le32(GPT_ENTRY_MAX),
+		.entry_size = cpu_to_le32(GPT_ENTRY_SIZE),
+	};
+	struct gpte  gpte[GPT_ENTRY_MAX];
+	uint64_t start, end, sect = 0;
+	int fd, ret = -1;
+	unsigned i;
+
+	memset(gpte, 0, GPT_ENTRY_SIZE * GPT_ENTRY_MAX);
+	for (i = 0; i < nr; i++) {
+		if (!parts[i].size) {
+			if (ignore_null_sized_partition)
+				continue;
+			fprintf(stderr, "Invalid size in partition %d!\n", i);
+			return ret;
+		}
+		start = sect + sectors;
+		if (kb_align != 0)
+			start = round_to_kb(start);
+		gpte[i].start = cpu_to_le64(start);
+
+		sect = start + parts[i].size * 2;
+		if (kb_align == 0)
+			sect = round_to_cyl(sect);
+		gpte[i].end = cpu_to_le64(sect -1);
+		gpte[i].guid = guid;
+		gpte[i].guid.b[sizeof(guid_t) -1] += i + 1;
+		if (parts[i].type == 0xEF || (i + 1) == active) {
+			gpte[i].type = GUID_PARTITION_SYSTEM;
+			init_utf16("EFI System Partition", gpte[i].name, GPT_ENTRY_NAME_SIZE / sizeof(uint16_t));
+		} else {
+			gpte[i].type = GUID_PARTITION_BASIC_DATA;
+		}
+
+		if (verbose)
+			fprintf(stderr, "Partition %d: start=%lld, end=%lld, size=%lld\n",
+					i,
+					start * DISK_SECTOR_SIZE, sect * DISK_SECTOR_SIZE,
+					(sect - start) * DISK_SECTOR_SIZE);
+		printf("%lld\n", start * DISK_SECTOR_SIZE);
+		printf("%lld\n", (sect - start) * DISK_SECTOR_SIZE);
+	}
+
+	gpte[GPT_ENTRY_MAX - 1].start = cpu_to_le64(GPT_FIRST_ENTRY_SECTOR + GPT_ENTRY_SIZE * GPT_ENTRY_MAX / DISK_SECTOR_SIZE);
+	gpte[GPT_ENTRY_MAX - 1].end = cpu_to_le64((kb_align ? round_to_kb(sectors) : sectors) - 1);
+	gpte[GPT_ENTRY_MAX - 1].type = GUID_PARTITION_BIOS_BOOT;
+	gpte[GPT_ENTRY_MAX - 1].guid = guid;
+	gpte[GPT_ENTRY_MAX - 1].guid.b[sizeof(guid_t) -1] += GPT_ENTRY_MAX;
+
+	end = sect + sectors - 1;
+
+	pte.type = 0xEE;
+	pte.start = cpu_to_le32(GPT_HEADER_SECTOR);
+	pte.length = cpu_to_le32(end);
+	to_chs(GPT_HEADER_SECTOR, pte.chs_start);
+	to_chs(end, pte.chs_end);
+
+	gpth.last_usable = cpu_to_le64(end - GPT_ENTRY_SIZE * GPT_ENTRY_MAX / DISK_SECTOR_SIZE - 1);
+	gpth.alternate = cpu_to_le64(end);
+	gpth.entry_crc32 = cpu_to_le32(gpt_crc32(gpte, GPT_ENTRY_SIZE * GPT_ENTRY_MAX));
+	gpth.crc32 = cpu_to_le32(gpt_crc32((char *)&gpth, GPT_HEADER_SIZE));
+
+	if ((fd = open(filename, O_WRONLY|O_CREAT|O_TRUNC, 0644)) < 0) {
+		fprintf(stderr, "Can't open output file '%s'\n",filename);
+		return ret;
+	}
+
+	lseek(fd, MBR_DISK_SIGNATURE_OFFSET, SEEK_SET);
+	if (write(fd, &signature, sizeof(signature)) != sizeof(signature)) {
+		fputs("write failed.\n", stderr);
+		goto fail;
+	}
+
+	lseek(fd, MBR_PARTITION_ENTRY_OFFSET, SEEK_SET);
+	if (write(fd, &pte, sizeof(struct pte)) != sizeof(struct pte)) {
+		fputs("write failed.\n", stderr);
+		goto fail;
+	}
+
+	lseek(fd, MBR_BOOT_SIGNATURE_OFFSET, SEEK_SET);
+	if (write(fd, "\x55\xaa", 2) != 2) {
+		fputs("write failed.\n", stderr);
+		goto fail;
+	}
+
+	//lseek(fd, GPT_HEADER_SECTOR * DISK_SECTOR_SIZE, SEEK_SET);
+	if (write(fd, &gpth, GPT_HEADER_SIZE) != GPT_HEADER_SIZE) {
+		fputs("write failed.\n", stderr);
+		goto fail;
+	}
+
+	lseek(fd, GPT_FIRST_ENTRY_SECTOR * DISK_SECTOR_SIZE, SEEK_SET);
+	if (write(fd, &gpte, GPT_ENTRY_SIZE * GPT_ENTRY_MAX) != GPT_ENTRY_SIZE * GPT_ENTRY_MAX) {
+		fputs("write failed.\n", stderr);
+		goto fail;
+	}
+
+#if 0
+	/* The alternate partition table (We omit it) */
+	swap(gpth.self, gpth.alternate);
+	gpth.first_entry = cpu_to_le64(end - GPT_ENTRY_SIZE * GPT_ENTRY_MAX / DISK_SECTOR_SIZE),
+	gpth.crc32 = 0;
+	gpth.crc32 = cpu_to_le32(gpt_crc32(&gpth, GPT_HEADER_SIZE));
+
+	lseek(fd, end * DISK_SECTOR_SIZE - GPT_ENTRY_SIZE * GPT_ENTRY_MAX, SEEK_SET);
+	if (write(fd, &gpte, GPT_ENTRY_SIZE * GPT_ENTRY_MAX) != GPT_ENTRY_SIZE * GPT_ENTRY_MAX) {
+		fputs("write failed.\n", stderr);
+		goto fail;
+	}
+
+	lseek(fd, end * DISK_SECTOR_SIZE, SEEK_SET);
+	if (write(fd, &gpth, GPT_HEADER_SIZE) != GPT_HEADER_SIZE) {
+		fputs("write failed.\n", stderr);
+		goto fail;
+	}
+	lseek(fd, (end + 1) * DISK_SECTOR_SIZE -1, SEEK_SET);
+	if (write(fd, "\x00", 1) != 1) {
+		fputs("write failed.\n", stderr);
+		goto fail;
+	}
+#endif
+
+	ret = 0;
+fail:
+	close(fd);
+	return ret;
+}
+
 static void usage(char *prog)
 {
-	fprintf(stderr, "Usage: %s [-v] [-n] -h <heads> -s <sectors> -o <outputfile> [-a 0..4] [-l <align kB>] [[-t <type>] -p <size>...] \n", prog);
+	fprintf(stderr, "Usage: %s [-v] [-n] [-g] -h <heads> -s <sectors> -o <outputfile> [-a 0..4] [-l <align kB>] [-G <guid>] [[-t <type>] -p <size>...] \n", prog);
 	exit(EXIT_FAILURE);
 }
 
 int main (int argc, char **argv)
 {
-	char type = 0x83;
+	unsigned char type = 0x83;
 	int ch;
 	int part = 0;
 	uint32_t signature = 0x5452574F; /* 'OWRT' */
+	guid_t guid = GUID_INIT( signature, 0x2211, 0x4433, \
+			0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0x00);
 
-	while ((ch = getopt(argc, argv, "h:s:p:a:t:o:vnl:S:")) != -1) {
+	while ((ch = getopt(argc, argv, "h:s:p:a:t:o:vngl:S:G:")) != -1) {
 		switch (ch) {
 		case 'o':
 			filename = optarg;
@@ -222,6 +498,9 @@ int main (int argc, char **argv)
 		case 'n':
 			ignore_null_sized_partition = true;
 			break;
+		case 'g':
+			use_guid_partition_table = 1;
+			break;
 		case 'h':
 			heads = (int)strtoul(optarg, NULL, 0);
 			break;
@@ -229,8 +508,8 @@ int main (int argc, char **argv)
 			sectors = (int)strtoul(optarg, NULL, 0);
 			break;
 		case 'p':
-			if (part > 3) {
-				fprintf(stderr, "Too many partitions\n");
+			if (part > GPT_ENTRY_MAX - 1 || (!use_guid_partition_table && part > 3)) {
+				fputs("Too many partitions\n", stderr);
 				exit(EXIT_FAILURE);
 			}
 			parts[part].size = to_kbytes(optarg);
@@ -250,6 +529,12 @@ int main (int argc, char **argv)
 		case 'S':
 			signature = strtoul(optarg, NULL, 0);
 			break;
+		case 'G':
+			if (guid_parse(optarg, &guid)) {
+				fputs("Invalid guid string\n", stderr);
+				exit(EXIT_FAILURE);
+			}
+			break;
 		case '?':
 		default:
 			usage(argv[0]);
@@ -259,5 +544,9 @@ int main (int argc, char **argv)
 	if (argc || (heads <= 0) || (sectors <= 0) || !filename)
 		usage(argv[0]);
 
-	return gen_ptable(signature, part) ? EXIT_FAILURE : EXIT_SUCCESS;
+	if (use_guid_partition_table) {
+		return gen_gptable(signature, guid, part) ? EXIT_FAILURE : EXIT_SUCCESS;
+	} else {
+		return gen_ptable(signature, part) ? EXIT_FAILURE : EXIT_SUCCESS;
+	}
 }

From c634da575c221e6a340884219d78978f56f23976 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=9D=8E=E5=9B=BD?= <uxgood.org@gmail.com>
Date: Thu, 4 Apr 2019 03:17:01 +0000
Subject: [PATCH 2/8] grub2: split to grub2 and grub2-efi packages
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

EFI bootable images need grub2 host packages with efi platform,
but grub2 can not build efi platform and pc platform together,
so we split it to grub2 and grub2-efi packages.

Signed-off-by: 李国 <uxgood.org@gmail.com>
---
 package/boot/grub2/common.mk            | 54 +++++++++++++++++++++++++
 package/boot/grub2/grub2-efi/Makefile   | 19 +++++++++
 package/boot/grub2/{ => grub2}/Makefile | 50 +----------------------
 3 files changed, 75 insertions(+), 48 deletions(-)
 create mode 100644 package/boot/grub2/common.mk
 create mode 100644 package/boot/grub2/grub2-efi/Makefile
 rename package/boot/grub2/{ => grub2}/Makefile (66%)

diff --git a/package/boot/grub2/common.mk b/package/boot/grub2/common.mk
new file mode 100644
index 00000000000..53ee26552f8
--- /dev/null
+++ b/package/boot/grub2/common.mk
@@ -0,0 +1,54 @@
+#
+# Copyright (C) 2006-2015 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=grub
+PKG_CPE_ID:=cpe:/a:gnu:grub2
+PKG_VERSION:=2.04
+PKG_RELEASE:=2
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.xz
+PKG_SOURCE_URL:=@GNU/grub
+PKG_HASH:=e5292496995ad42dabe843a0192cf2a2c502e7ffcc7479398232b10a472df77d
+
+HOST_BUILD_PARALLEL:=1
+
+PKG_SSP:=0
+
+PKG_FLAGS:=nonshared
+
+PATCH_DIR:=../patches
+
+HOST_BUILD_DIR ?= $(BUILD_DIR_HOST)/$(PKG_NAME)-$(GRUB_PLATFORM)/$(PKG_NAME)$(if $(PKG_VERSION),-$(PKG_VERSION))
+HOST_BUILD_PREFIX := $(STAGING_DIR_HOST)
+
+include $(INCLUDE_DIR)/host-build.mk
+include $(INCLUDE_DIR)/package.mk
+
+
+HOST_CONFIGURE_VARS += \
+	grub_build_mkfont_excuse="don't want fonts"
+
+HOST_CONFIGURE_ARGS += \
+	--disable-grub-mkfont \
+	--target=$(REAL_GNU_TARGET_NAME) \
+	--sbindir="$(STAGING_DIR_HOST)/bin" \
+	--disable-werror \
+	--disable-libzfs \
+	--disable-nls \
+	--with-platform=$(GRUB_PLATFORM)
+
+HOST_MAKE_FLAGS += \
+	TARGET_RANLIB=$(TARGET_RANLIB) \
+	LIBLZMA=$(STAGING_DIR_HOST)/lib/liblzma.a
+
+define Host/Configure
+	$(SED) 's,(RANLIB),(TARGET_RANLIB),' $(HOST_BUILD_DIR)/grub-core/Makefile.in
+	$(Host/Configure/Default)
+endef
diff --git a/package/boot/grub2/grub2-efi/Makefile b/package/boot/grub2/grub2-efi/Makefile
new file mode 100644
index 00000000000..2fc21fdb890
--- /dev/null
+++ b/package/boot/grub2/grub2-efi/Makefile
@@ -0,0 +1,19 @@
+GRUB_PLATFORM:=efi
+
+PKG_BUILD_DEPENDS:=grub2-efi/host
+include ../common.mk
+
+define Package/grub2-efi
+  CATEGORY:=Boot Loaders
+  SECTION:=boot
+  TITLE:=GRand Unified Bootloader(EFI)
+  URL:=http://www.gnu.org/software/grub/
+  DEPENDS:=@TARGET_x86
+endef
+
+define Host/Install
+	$(call Host/Compile/Default,install-data)
+endef
+
+$(eval $(call HostBuild))
+$(eval $(call BuildPackage,grub2-efi))
diff --git a/package/boot/grub2/Makefile b/package/boot/grub2/grub2/Makefile
similarity index 66%
rename from package/boot/grub2/Makefile
rename to package/boot/grub2/grub2/Makefile
index 980a6e372a3..7126beab4cf 100644
--- a/package/boot/grub2/Makefile
+++ b/package/boot/grub2/grub2/Makefile
@@ -1,31 +1,7 @@
-#
-# Copyright (C) 2006-2015 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
-#
+GRUB_PLATFORM:=pc
 
-include $(TOPDIR)/rules.mk
-include $(INCLUDE_DIR)/kernel.mk
-
-PKG_NAME:=grub
-PKG_CPE_ID:=cpe:/a:gnu:grub2
-PKG_VERSION:=2.04
-PKG_RELEASE:=1
-
-PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.xz
-PKG_SOURCE_URL:=@GNU/grub
-PKG_HASH:=e5292496995ad42dabe843a0192cf2a2c502e7ffcc7479398232b10a472df77d
-
-HOST_BUILD_PARALLEL:=1
 PKG_BUILD_DEPENDS:=grub2/host
-
-PKG_SSP:=0
-
-PKG_FLAGS:=nonshared
-
-include $(INCLUDE_DIR)/host-build.mk
-include $(INCLUDE_DIR)/package.mk
+include ../common.mk
 
 define Package/grub2
   CATEGORY:=Boot Loaders
@@ -48,8 +24,6 @@ define Package/grub2-editenv/description
 	Edit grub2 environment files.
 endef
 
-HOST_BUILD_PREFIX := $(STAGING_DIR_HOST)
-
 CONFIGURE_VARS += \
 	grub_build_mkfont_excuse="don't want fonts"
 
@@ -62,26 +36,6 @@ CONFIGURE_ARGS += \
 	--disable-grub-mkfont \
 	--with-platform=none
 
-HOST_CONFIGURE_VARS += \
-	grub_build_mkfont_excuse="don't want fonts"
-
-HOST_CONFIGURE_ARGS += \
-	--disable-grub-mkfont \
-	--target=$(REAL_GNU_TARGET_NAME) \
-	--sbindir="$(STAGING_DIR_HOST)/bin" \
-	--disable-werror \
-	--disable-libzfs \
-	--disable-nls
-
-HOST_MAKE_FLAGS += \
-	TARGET_RANLIB=$(TARGET_RANLIB) \
-	LIBLZMA=$(STAGING_DIR_HOST)/lib/liblzma.a
-
-define Host/Configure
-	$(SED) 's,(RANLIB),(TARGET_RANLIB),' $(HOST_BUILD_DIR)/grub-core/Makefile.in
-	$(Host/Configure/Default)
-endef
-
 define Host/Install
 	$(call Host/Install/Default)
 

From 15212ac11ac95a57f75317fff83bb7d53b581a93 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=9D=8E=E5=9B=BD?= <uxgood.org@gmail.com>
Date: Thu, 4 Apr 2019 03:42:16 +0000
Subject: [PATCH 3/8] x86: add EFI images and make iso images EFI bootable
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Add EFI bootable images for x86 platforms. These images can also
boot from legacy BIOS. And iso images can boot from EFI now.

EFI System Partition need to be fat12/fat16/fat32 (not need to load
filesystem drivers), so the first partition of EFI images are not ext4
filesystem any more.

GPT partition table has an alternate partition table, we did not
generate it. This may cause problems when use these images as qemu disk,
kernel can not find rootfs, we pad enough sectors will be ok.

Signed-off-by: 李国 <uxgood.org@gmail.com>
---
 config/Config-images.in                       | 23 +++++++++++++------
 .../base-files/files/lib/upgrade/common.sh    | 11 +++++++++
 scripts/gen_image_generic.sh                  | 10 ++++++--
 .../x86/base-files/lib/preinit/79_move_config |  6 +++--
 .../x86/base-files/lib/upgrade/platform.sh    |  6 +++--
 target/linux/x86/generic/config-4.19          |  1 +
 target/linux/x86/generic/config-5.4           |  1 +
 target/linux/x86/image/Makefile               |  3 +++
 target/linux/x86/image/grub-iso.cfg           |  7 +++++-
 9 files changed, 54 insertions(+), 14 deletions(-)

diff --git a/config/Config-images.in b/config/Config-images.in
index e4db0482ce2..16b575247ea 100644
--- a/config/Config-images.in
+++ b/config/Config-images.in
@@ -188,19 +188,28 @@ menu "Target Images"
 		select PACKAGE_grub2
 		default y
 
+	config EFI_IMAGES
+		bool "Build EFI images (Linux x86 or x86_64 host only)"
+		depends on TARGET_x86
+		depends on TARGET_ROOTFS_EXT4FS || TARGET_ROOTFS_ISO || TARGET_ROOTFS_JFFS2 || TARGET_ROOTFS_SQUASHFS
+		select PACKAGE_grub2
+		select PACKAGE_grub2-efi
+		select PACKAGE_kmod-fs-vfat
+		default n
+
 	config GRUB_CONSOLE
 		bool "Use Console Terminal (in addition to Serial)"
-		depends on GRUB_IMAGES
+		depends on GRUB_IMAGES || EFI_IMAGES
 		default y
 
 	config GRUB_SERIAL
 		string "Serial port device"
-		depends on GRUB_IMAGES
+		depends on GRUB_IMAGES || EFI_IMAGES
 		default "ttyS0"
 
 	config GRUB_BAUDRATE
 		int "Serial port baud rate"
-		depends on GRUB_IMAGES
+		depends on GRUB_IMAGES || EFI_IMAGES
 		default 38400 if TARGET_x86_generic
 		default 115200
 
@@ -211,20 +220,20 @@ menu "Target Images"
 
 	config GRUB_BOOTOPTS
 		string "Extra kernel boot options"
-		depends on GRUB_IMAGES
+		depends on GRUB_IMAGES || EFI_IMAGES
 		help
 		  If you don't know, just leave it blank.
 
 	config GRUB_TIMEOUT
 		string "Seconds to wait before booting the default entry"
-		depends on GRUB_IMAGES
+		depends on GRUB_IMAGES || EFI_IMAGES
 		default "5"
 		help
 		  If you don't know, 5 seconds is a reasonable default.
 
 	config GRUB_TITLE
 		string "Title for the menu entry in GRUB"
-		depends on GRUB_IMAGES
+		depends on GRUB_IMAGES || EFI_IMAGES
 		default "OpenWrt"
 		help
 		  This is the title of the GRUB menu entry.
@@ -272,7 +281,7 @@ menu "Target Images"
 
 	config TARGET_ROOTFS_PARTNAME
 		string "Root partition on target device"
-		depends on GRUB_IMAGES
+		depends on GRUB_IMAGES || EFI_IMAGES
 		help
 		  Override the root partition on the final device. If left empty,
 		  it will be mounted by PARTUUID which makes the kernel find the
diff --git a/package/base-files/files/lib/upgrade/common.sh b/package/base-files/files/lib/upgrade/common.sh
index a986cc0b5c7..6e967aeffe8 100644
--- a/package/base-files/files/lib/upgrade/common.sh
+++ b/package/base-files/files/lib/upgrade/common.sh
@@ -136,6 +136,17 @@ export_bootdevice() {
 					fi
 				done
 			;;
+			PARTUUID=????????-????-????-????-??????????02)
+				uuid="${rootpart#PARTUUID=}"
+				uuid="${uuid%02}00"
+				for disk in $(find /dev -type b); do
+					set -- $(dd if=$disk bs=1 skip=568 count=16 2>/dev/null | hexdump -v -e '8/1 "%02x "" "2/1 "%02x""-"6/1 "%02x"')
+					if [ "$4$3$2$1-$6$5-$8$7-$9" = "$uuid" ]; then
+						uevent="/sys/class/block/${disk##*/}/uevent"
+						break
+					fi
+				done
+			;;
 			/dev/*)
 				uevent="/sys/class/block/${rootpart##*/}/../uevent"
 			;;
diff --git a/scripts/gen_image_generic.sh b/scripts/gen_image_generic.sh
index 2c57d56f073..1df4d0673b3 100755
--- a/scripts/gen_image_generic.sh
+++ b/scripts/gen_image_generic.sh
@@ -20,7 +20,7 @@ sect=63
 cyl=$(( (KERNELSIZE + ROOTFSSIZE) * 1024 * 1024 / (head * sect * 512)))
 
 # create partition table
-set $(ptgen -o "$OUTPUT" -h $head -s $sect -p ${KERNELSIZE}m -p ${ROOTFSSIZE}m ${ALIGN:+-l $ALIGN} ${SIGNATURE:+-S 0x$SIGNATURE})
+set $(ptgen -o "$OUTPUT" -h $head -s $sect ${EFI_SIGNATURE:+-g} -p ${KERNELSIZE}m -p ${ROOTFSSIZE}m ${ALIGN:+-l $ALIGN} ${SIGNATURE:+-S 0x$SIGNATURE} ${EFI_SIGNATURE:+-G $EFI_SIGNATURE})
 
 KERNELOFFSET="$(($1 / 512))"
 KERNELSIZE="$2"
@@ -30,6 +30,12 @@ ROOTFSSIZE="$(($4 / 512))"
 [ -n "$PADDING" ] && dd if=/dev/zero of="$OUTPUT" bs=512 seek="$ROOTFSOFFSET" conv=notrunc count="$ROOTFSSIZE"
 dd if="$ROOTFSIMAGE" of="$OUTPUT" bs=512 seek="$ROOTFSOFFSET" conv=notrunc
 
-make_ext4fs -J -L kernel -l "$KERNELSIZE" "$OUTPUT.kernel" "$KERNELDIR"
+if [ -n "$EFI_SIGNATURE" ]; then
+    [ -n "$PADDING" ] && dd if=/dev/zero of="$OUTPUT" bs=512 seek="$(($ROOTFSOFFSET + $ROOTFSSIZE))" conv=notrunc count="$sect"
+    mkfs.fat -n kernel -C "$OUTPUT.kernel" -S 512 "$(($KERNELSIZE / 1024))"
+    mcopy -s -i "$OUTPUT.kernel" "$KERNELDIR"/* ::/
+else
+    make_ext4fs -J -L kernel -l "$KERNELSIZE" "$OUTPUT.kernel" "$KERNELDIR"
+fi
 dd if="$OUTPUT.kernel" of="$OUTPUT" bs=512 seek="$KERNELOFFSET" conv=notrunc
 rm -f "$OUTPUT.kernel"
diff --git a/target/linux/x86/base-files/lib/preinit/79_move_config b/target/linux/x86/base-files/lib/preinit/79_move_config
index 702da9e873d..015efcf748b 100644
--- a/target/linux/x86/base-files/lib/preinit/79_move_config
+++ b/target/linux/x86/base-files/lib/preinit/79_move_config
@@ -2,13 +2,15 @@
 # Copyright (C) 2012-2015 OpenWrt.org
 
 move_config() {
-	local partdev
+	local partdev magic parttype=ext4
 
 	. /lib/upgrade/common.sh
 
 	if export_bootdevice && export_partdevice partdev 1; then
 		mkdir -p /boot
-		mount -t ext4 -o rw,noatime "/dev/$partdev" /boot
+		magic=$(dd if="/dev/$partdev" bs=1 count=3 skip=54 2>/dev/null)
+		[ "$magic" = "FAT" ] && parttype=vfat
+		mount -t $parttype -o rw,noatime "/dev/$partdev" /boot
 		if [ -f "/boot/$BACKUP_FILE" ]; then
 			mv -f "/boot/$BACKUP_FILE" /
 		fi
diff --git a/target/linux/x86/base-files/lib/upgrade/platform.sh b/target/linux/x86/base-files/lib/upgrade/platform.sh
index 53c751861cc..1c93f5bd9b9 100644
--- a/target/linux/x86/base-files/lib/upgrade/platform.sh
+++ b/target/linux/x86/base-files/lib/upgrade/platform.sh
@@ -37,10 +37,12 @@ platform_check_image() {
 }
 
 platform_copy_config() {
-	local partdev
+	local partdev magic parttype=ext4
 
 	if export_partdevice partdev 1; then
-		mount -t ext4 -o rw,noatime "/dev/$partdev" /mnt
+		magic=$(dd if="/dev/$partdev" bs=1 count=3 skip=54 2>/dev/null)
+		[ "$magic" = "FAT" ] && parttype=vfat
+		mount -t $parttype -o rw,noatime "/dev/$partdev" /mnt
 		cp -af "$UPGRADE_BACKUP" "/mnt/$BACKUP_FILE"
 		umount /mnt
 	fi
diff --git a/target/linux/x86/generic/config-4.19 b/target/linux/x86/generic/config-4.19
index 4a689ca026c..ada81ce04ea 100644
--- a/target/linux/x86/generic/config-4.19
+++ b/target/linux/x86/generic/config-4.19
@@ -139,6 +139,7 @@ CONFIG_FB_DEFERRED_IO=y
 CONFIG_FB_EFI=y
 CONFIG_FB_HYPERV=y
 # CONFIG_FB_I810 is not set
+CONFIG_FB_SIMPLE=y
 CONFIG_FB_SYS_COPYAREA=y
 CONFIG_FB_SYS_FILLRECT=y
 CONFIG_FB_SYS_FOPS=y
diff --git a/target/linux/x86/generic/config-5.4 b/target/linux/x86/generic/config-5.4
index 4a689ca026c..ada81ce04ea 100644
--- a/target/linux/x86/generic/config-5.4
+++ b/target/linux/x86/generic/config-5.4
@@ -139,6 +139,7 @@ CONFIG_FB_DEFERRED_IO=y
 CONFIG_FB_EFI=y
 CONFIG_FB_HYPERV=y
 # CONFIG_FB_I810 is not set
+CONFIG_FB_SIMPLE=y
 CONFIG_FB_SYS_COPYAREA=y
 CONFIG_FB_SYS_FILLRECT=y
 CONFIG_FB_SYS_FOPS=y
diff --git a/target/linux/x86/image/Makefile b/target/linux/x86/image/Makefile
index c2961e5b9c9..aa80d77b978 100644
--- a/target/linux/x86/image/Makefile
+++ b/target/linux/x86/image/Makefile
@@ -38,6 +38,9 @@ endif
 
 ROOTPART:=$(call qstrip,$(CONFIG_TARGET_ROOTFS_PARTNAME))
 ROOTPART:=$(if $(ROOTPART),$(ROOTPART),PARTUUID=$(IMG_PART_SIGNATURE)-02)
+EFI_SIGNATURE:=$(strip $(shell uuidgen | sed -r 's/[a-zA-Z0-9]{2}$$/00/'))
+EFI_ROOTPART:=$(call qstrip,$(CONFIG_TARGET_ROOTFS_PARTNAME))
+EFI_ROOTPART:=$(if $(EFI_ROOTPART),$(EFI_ROOTPART),PARTUUID=$(shell echo $(EFI_SIGNATURE) | sed 's/00$$/02/'))
 
 GRUB_TIMEOUT:=$(call qstrip,$(CONFIG_GRUB_TIMEOUT))
 GRUB_TITLE:=$(call qstrip,$(CONFIG_GRUB_TITLE))
diff --git a/target/linux/x86/image/grub-iso.cfg b/target/linux/x86/image/grub-iso.cfg
index f5848b38534..4bef492a414 100644
--- a/target/linux/x86/image/grub-iso.cfg
+++ b/target/linux/x86/image/grub-iso.cfg
@@ -3,7 +3,12 @@
 
 set default="0"
 set timeout="@TIMEOUT@"
-set root='(cd)'
+
+if [ "${grub_platform}" = "efi" ]; then
+    set root='(cd0)'
+else
+    set root='(cd)'
+fi
 
 menuentry "@TITLE@" {
 	linux /boot/vmlinuz root=/dev/sr0 rootfstype=iso9660 rootwait @CMDLINE@ noinitrd

From c24086b352f6f773c07f15f85b0e5ffe26e206af Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=9D=8E=E5=9B=BD?= <uxgood.org@gmail.com>
Date: Sat, 31 Aug 2019 13:28:05 +0000
Subject: [PATCH 4/8] x86: fix sysupgrade for EFI images
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

1. make function get_partitions support GPT disks
2. get more bytes from image to get GPT partition table
3. update the original PARTUUID to new grub.cfg

Signed-off-by: 李国 <uxgood.org@gmail.com>
---
 .../base-files/files/lib/upgrade/common.sh    | 40 ++++++++++++++-----
 .../x86/base-files/lib/upgrade/platform.sh    | 20 ++++++++--
 2 files changed, 45 insertions(+), 15 deletions(-)

diff --git a/package/base-files/files/lib/upgrade/common.sh b/package/base-files/files/lib/upgrade/common.sh
index 6e967aeffe8..1324b98ed2f 100644
--- a/package/base-files/files/lib/upgrade/common.sh
+++ b/package/base-files/files/lib/upgrade/common.sh
@@ -218,17 +218,35 @@ get_partitions() { # <device> <filename>
 		rm -f "/tmp/partmap.$filename"
 
 		local part
-		for part in 1 2 3 4; do
-			set -- $(hexdump -v -n 12 -s "$((0x1B2 + $part * 16))" -e '3/4 "0x%08X "' "$disk")
-
-			local type="$(( $(hex_le32_to_cpu $1) % 256))"
-			local lba="$(( $(hex_le32_to_cpu $2) ))"
-			local num="$(( $(hex_le32_to_cpu $3) ))"
-
-			[ $type -gt 0 ] || continue
-
-			printf "%2d %5d %7d\n" $part $lba $num >> "/tmp/partmap.$filename"
-		done
+		local magic=$(dd if="$disk" bs=8 count=1 skip=64 2>/dev/null)
+		if [ "$magic" = "EFI PART" ]; then
+			#export_partdevice will fail when partition number is greater than 15, as
+			#the partition major device number is not equal to the disk major device number
+			for part in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
+				set -- $(hexdump -v -n 48 -s "$((0x380 + $part * 0x80))" -e '4/4 "%08x"" "4/4 "%08x"" "4/4 "0x%08X "' "$disk")
+
+				local type="$1"
+				local lba="$(( $(hex_le32_to_cpu $4) * 0x100000000 + $(hex_le32_to_cpu $3) ))"
+				local end="$(( $(hex_le32_to_cpu $6) * 0x100000000 + $(hex_le32_to_cpu $5) ))"
+				local num="$(( $end - $lba ))"
+
+				[ "$type" = "00000000000000000000000000000000" ] && continue
+
+				printf "%2d %5d %7d\n" $part $lba $num >> "/tmp/partmap.$filename"
+			done
+		else
+			for part in 1 2 3 4; do
+				set -- $(hexdump -v -n 12 -s "$((0x1B2 + $part * 16))" -e '3/4 "0x%08X "' "$disk")
+
+				local type="$(( $(hex_le32_to_cpu $1) % 256))"
+				local lba="$(( $(hex_le32_to_cpu $2) ))"
+				local num="$(( $(hex_le32_to_cpu $3) ))"
+
+				[ $type -gt 0 ] || continue
+
+				printf "%2d %5d %7d\n" $part $lba $num >> "/tmp/partmap.$filename"
+			done
+		fi
 	fi
 }
 
diff --git a/target/linux/x86/base-files/lib/upgrade/platform.sh b/target/linux/x86/base-files/lib/upgrade/platform.sh
index 1c93f5bd9b9..3acee2c7a9c 100644
--- a/target/linux/x86/base-files/lib/upgrade/platform.sh
+++ b/target/linux/x86/base-files/lib/upgrade/platform.sh
@@ -20,7 +20,7 @@ platform_check_image() {
 	get_partitions "/dev/$diskdev" bootdisk
 
 	#extract the boot sector from the image
-	get_image "$@" | dd of=/tmp/image.bs count=1 bs=512b 2>/dev/null
+	get_image "$@" | dd of=/tmp/image.bs count=63 bs=512b 2>/dev/null
 
 	get_partitions /tmp/image.bs image
 
@@ -40,7 +40,7 @@ platform_copy_config() {
 	local partdev magic parttype=ext4
 
 	if export_partdevice partdev 1; then
-		magic=$(dd if="/dev/$partdev" bs=1 count=3 skip=54 2>/dev/null)
+		magic="$(dd if="/dev/$partdev" bs=1 count=3 skip=54 2>/dev/null)"
 		[ "$magic" = "FAT" ] && parttype=vfat
 		mount -t $parttype -o rw,noatime "/dev/$partdev" /mnt
 		cp -af "$UPGRADE_BACKUP" "/mnt/$BACKUP_FILE"
@@ -83,7 +83,7 @@ platform_do_upgrade() {
 		get_partitions "/dev/$diskdev" bootdisk
 
 		#extract the boot sector from the image
-		get_image "$@" | dd of=/tmp/image.bs count=1 bs=512b
+		get_image "$@" | dd of=/tmp/image.bs count=63 bs=512b >/dev/null
 
 		get_partitions /tmp/image.bs image
 
@@ -108,7 +108,7 @@ platform_do_upgrade() {
 	while read part start size; do
 		if export_partdevice partdev $part; then
 			echo "Writing image to /dev/$partdev..."
-			get_image "$@" | dd of="/dev/$partdev" ibs="512" obs=1M skip="$start" count="$size" conv=fsync
+			get_image "$@" | dd of="/dev/$partdev" ibs=512 obs=1M skip="$start" count="$size" conv=fsync
 		else
 			echo "Unable to find partition $part device, skipped."
 		fi
@@ -119,4 +119,16 @@ platform_do_upgrade() {
 	get_image "$@" | dd of="/dev/$diskdev" bs=1 skip=440 count=4 seek=440 conv=fsync
 
 	platform_do_bootloader_upgrade "$diskdev"
+	local magic parttype=ext4
+	magic="$(dd if="/dev/$diskdev" bs=8 count=1 skip=64 2>/dev/null)"
+	[ "$magic" = "EFI PART" ] || return 0
+	if export_partdevice partdev 1; then
+		magic="$(dd if="/dev/$partdev" bs=1 count=3 skip=54 2>/dev/null)"
+		[ "$magic" = "FAT" ] && parttype=vfat
+		mount -t $parttype -o rw,noatime "/dev/$partdev" /mnt
+		set -- $(dd if="/dev/$diskdev" bs=1 skip=1168 count=16 2>/dev/null | hexdump -v -e '8/1 "%02x "" "2/1 "%02x""-"6/1 "%02x"')
+		sed -i "s/\(PARTUUID=\)[a-f0-9-]\+/\1$4$3$2$1-$6$5-$8$7-$9/ig" /mnt/boot/grub/grub.cfg
+		umount /mnt
+	fi
+
 }

From b915dff5280cc48a2331f01961f2504b9b12f245 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=9D=8E=E5=9B=BD?= <uxgood.org@gmail.com>
Date: Tue, 24 Mar 2020 17:12:22 +0800
Subject: [PATCH 5/8] grub2: grub-early.cfg auto detect efi platform
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: 李国 <uxgood.org@gmail.com>
---
 package/boot/grub2/files/grub-early.cfg | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/package/boot/grub2/files/grub-early.cfg b/package/boot/grub2/files/grub-early.cfg
index 4a5b5a60927..9e7cad47607 100644
--- a/package/boot/grub2/files/grub-early.cfg
+++ b/package/boot/grub2/files/grub-early.cfg
@@ -1 +1,5 @@
-configfile (hd0,msdos1)/boot/grub/grub.cfg
+if [ "${grub_platform}" = "efi" ]; then
+    configfile (hd0,gpt1)/boot/grub/grub.cfg
+else
+    configfile (hd0,msdos1)/boot/grub/grub.cfg
+fi

From dce4fc3201395f886e496c3bb5f6ffd979558aa3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=9D=8E=E5=9B=BD?= <uxgood.org@gmail.com>
Date: Tue, 24 Mar 2020 17:13:27 +0800
Subject: [PATCH 6/8] x86: add efi images

---
 include/image.mk                    |  1 +
 scripts/gen_image_generic.sh        |  4 ++--
 target/linux/x86/image/Makefile     | 34 +++++++++++++++++++++++++----
 target/linux/x86/image/grub-efi.cfg | 13 +++++++++++
 4 files changed, 46 insertions(+), 6 deletions(-)
 create mode 100644 target/linux/x86/image/grub-efi.cfg

diff --git a/include/image.mk b/include/image.mk
index 8af5905c600..051a6206cef 100644
--- a/include/image.mk
+++ b/include/image.mk
@@ -45,6 +45,7 @@ IMG_PREFIX:=$(VERSION_DIST_SANITIZED)-$(IMG_PREFIX_VERNUM)$(IMG_PREFIX_VERCODE)$
 IMG_ROOTFS:=$(IMG_PREFIX)-rootfs
 IMG_COMBINED:=$(IMG_PREFIX)-combined
 IMG_PART_SIGNATURE:=$(shell echo $(SOURCE_DATE_EPOCH)$(LINUX_VERMAGIC) | mkhash md5 | cut -b1-8)
+IMG_PART_UUID:=$(shell echo $(SOURCE_DATE_EPOCH)$(LINUX_VERMAGIC) | mkhash md5 | sed -r 's/(.{8})(.{4})(.{4})(.{4})(.{10})../\1-\2-\3-\4-\500/')
 
 MKFS_DEVTABLE_OPT := -D $(INCLUDE_DIR)/device_table.txt
 
diff --git a/scripts/gen_image_generic.sh b/scripts/gen_image_generic.sh
index 1df4d0673b3..e45a8dd417e 100755
--- a/scripts/gen_image_generic.sh
+++ b/scripts/gen_image_generic.sh
@@ -20,7 +20,7 @@ sect=63
 cyl=$(( (KERNELSIZE + ROOTFSSIZE) * 1024 * 1024 / (head * sect * 512)))
 
 # create partition table
-set $(ptgen -o "$OUTPUT" -h $head -s $sect ${EFI_SIGNATURE:+-g} -p ${KERNELSIZE}m -p ${ROOTFSSIZE}m ${ALIGN:+-l $ALIGN} ${SIGNATURE:+-S 0x$SIGNATURE} ${EFI_SIGNATURE:+-G $EFI_SIGNATURE})
+set $(ptgen -o "$OUTPUT" -h $head -s $sect ${UUID:+-g} -p ${KERNELSIZE}m -p ${ROOTFSSIZE}m ${ALIGN:+-l $ALIGN} ${SIGNATURE:+-S 0x$SIGNATURE} ${UUID:+-G $UUID})
 
 KERNELOFFSET="$(($1 / 512))"
 KERNELSIZE="$2"
@@ -30,7 +30,7 @@ ROOTFSSIZE="$(($4 / 512))"
 [ -n "$PADDING" ] && dd if=/dev/zero of="$OUTPUT" bs=512 seek="$ROOTFSOFFSET" conv=notrunc count="$ROOTFSSIZE"
 dd if="$ROOTFSIMAGE" of="$OUTPUT" bs=512 seek="$ROOTFSOFFSET" conv=notrunc
 
-if [ -n "$EFI_SIGNATURE" ]; then
+if [ -n "$UUID" ]; then
     [ -n "$PADDING" ] && dd if=/dev/zero of="$OUTPUT" bs=512 seek="$(($ROOTFSOFFSET + $ROOTFSSIZE))" conv=notrunc count="$sect"
     mkfs.fat -n kernel -C "$OUTPUT.kernel" -S 512 "$(($KERNELSIZE / 1024))"
     mcopy -s -i "$OUTPUT.kernel" "$KERNELDIR"/* ::/
diff --git a/target/linux/x86/image/Makefile b/target/linux/x86/image/Makefile
index aa80d77b978..efb0b1cff99 100644
--- a/target/linux/x86/image/Makefile
+++ b/target/linux/x86/image/Makefile
@@ -38,9 +38,8 @@ endif
 
 ROOTPART:=$(call qstrip,$(CONFIG_TARGET_ROOTFS_PARTNAME))
 ROOTPART:=$(if $(ROOTPART),$(ROOTPART),PARTUUID=$(IMG_PART_SIGNATURE)-02)
-EFI_SIGNATURE:=$(strip $(shell uuidgen | sed -r 's/[a-zA-Z0-9]{2}$$/00/'))
 EFI_ROOTPART:=$(call qstrip,$(CONFIG_TARGET_ROOTFS_PARTNAME))
-EFI_ROOTPART:=$(if $(EFI_ROOTPART),$(EFI_ROOTPART),PARTUUID=$(shell echo $(EFI_SIGNATURE) | sed 's/00$$/02/'))
+EFI_ROOTPART:=$(if $(EFI_ROOTPART),$(EFI_ROOTPART),PARTUUID=$(shell echo $(IMG_PART_UUID) | sed 's/00$$/02/'))
 
 GRUB_TIMEOUT:=$(call qstrip,$(CONFIG_GRUB_TIMEOUT))
 GRUB_TITLE:=$(call qstrip,$(CONFIG_GRUB_TITLE))
@@ -50,7 +49,8 @@ BOOTOPTS:=$(call qstrip,$(CONFIG_GRUB_BOOTOPTS))
 define Build/combined
 	$(CP) $(KDIR)/$(KERNEL_NAME) $@.boot/boot/vmlinuz
 	-$(CP) $(STAGING_DIR_ROOT)/boot/. $@.boot/boot/
-	PADDING="1" SIGNATURE="$(IMG_PART_SIGNATURE)" $(SCRIPT_DIR)/gen_image_generic.sh \
+	PADDING="1" SIGNATURE="$(IMG_PART_SIGNATURE)" \
+		$(if $(filter $(1),efi),UUID="$(IMG_PART_UUID)") $(SCRIPT_DIR)/gen_image_generic.sh \
 		$@ \
 		$(CONFIG_TARGET_KERNEL_PARTSIZE) $@.boot \
 		$(CONFIG_TARGET_ROOTFS_PARTSIZE) $(IMAGE_ROOTFS) \
@@ -64,6 +64,7 @@ define Build/grub-config
 		-e 's#@SERIAL_CONFIG@#$(strip $(GRUB_SERIAL_CONFIG))#g' \
 		-e 's#@TERMINAL_CONFIG@#$(strip $(GRUB_TERMINAL_CONFIG))#g' \
 		-e 's#@ROOTPART@#root=$(ROOTPART) rootwait#g' \
+		-e 's#@EFI_ROOTPART@#root=$(EFI_ROOTPART) rootwait#g' \
 		-e 's#@CMDLINE@#$(BOOTOPTS) $(GRUB_CONSOLE_CMDLINE)#g' \
 		-e 's#@TIMEOUT@#$(GRUB_TIMEOUT)#g' \
 		-e 's#@TITLE@#$(GRUB_TITLE)#g' \
@@ -80,7 +81,7 @@ define Build/grub-install
 	$(STAGING_DIR_HOST)/bin/grub-bios-setup \
 		-m "$@.grub2/device.map" \
 		-d "$@.grub2" \
-		-r "hd0,msdos1" \
+		-r "hd0,$(if $(filter $(1),efi),gpt1,msdos1)" \
 		$@
 endef
 
@@ -91,7 +92,9 @@ define Build/iso
 		$(STAGING_DIR_HOST)/lib/grub/grub2-iso/eltorito.img \
 		> $@.boot/boot/grub/eltorito.img
 	-$(CP) $(STAGING_DIR_ROOT)/boot/. $@.boot/boot/
+	$(if $(filter $(1),efi),$(CP) $(STAGING_DIR_HOST)/lib/grub/grub2-iso/efiboot.img $@.boot/boot/grub/)
 	mkisofs -R -b boot/grub/eltorito.img -no-emul-boot -boot-info-table \
+		$(if $(filter $(1),efi),-boot-load-size 4 -c boot.cat -eltorito-alt-boot -e boot/grub/efiboot.img -no-emul-boot) \
 		-o $@ $@.boot $(TARGET_DIR)
 endef
 
@@ -102,13 +105,25 @@ define Device/Default
   IMAGE/combined.img.gz := grub-config pc | combined | grub-install | gzip
   IMAGE/combined.vdi := grub-config pc | combined | grub-install | qemu-image vdi
   IMAGE/combined.vmdk := grub-config pc | combined | grub-install | qemu-image vmdk
   IMAGE/rootfs.img := append-rootfs
   IMAGE/rootfs.img.gz := append-rootfs | gzip
+  ARTIFACT/image-efi.iso := grub-config iso | iso efi
+  IMAGE/combined-efi.img := grub-config efi | combined efi | grub-install efi
+  IMAGE/combined-efi.img.gz := grub-config efi | combined efi | grub-install efi | gzip
+  IMAGE/combined-efi.vdi := grub-config efi | combined efi | grub-install efi | qemu-image vdi
+  IMAGE/combined-efi.vmdk := grub-config efi | combined efi | grub-install efi | qemu-image vmdk
   ifeq ($(CONFIG_TARGET_IMAGES_GZIP),y)
     IMAGES := combined.img.gz rootfs.img.gz
   else
     IMAGES := combined.img rootfs.img
   endif
+  ifeq $(CONFIG_EFI_IMAGES)
+    ifeq ($(CONFIG_TARGET_IMAGES_GZIP),y)
+      IMAGES += combined-efi.img.gz
+    else
+      IMAGES += combined-efi.img
+    endif
+  endif
   KERNEL := kernel-bin
   KERNEL_INSTALL := 1
   KERNEL_NAME := bzImage
@@ -119,6 +134,17 @@ define Device/Default
   ifeq ($(CONFIG_VMDK_IMAGES),y)
     IMAGES += combined.vmdk
   endif
+  ifeq $(CONFIG_EFI_IMAGES)
+    ifeq ($(CONFIG_ISO_IMAGES),y)
+      ARTIFACTS += image-efi.iso
+    endif
+    ifeq ($(CONFIG_VDI_IMAGES),y)
+      IMAGES += combined-efi.vdi
+    endif
+    ifeq ($(CONFIG_VMDK_IMAGES),y)
+      IMAGES += combined-efi.vmdk
+    endif
+  endif
 endef
 
 $(eval $(call Image/gzip-ext4-padded-squashfs))
diff --git a/target/linux/x86/image/grub-efi.cfg b/target/linux/x86/image/grub-efi.cfg
new file mode 100644
index 00000000000..f3f6a02c021
--- /dev/null
+++ b/target/linux/x86/image/grub-efi.cfg
@@ -0,0 +1,13 @@
+@SERIAL_CONFIG@
+@TERMINAL_CONFIG@
+
+set default="0"
+set timeout="@TIMEOUT@"
+set root='(hd0,gpt1)'
+
+menuentry "@TITLE@" {
+	linux /boot/vmlinuz @EFI_ROOTPART@ @CMDLINE@ noinitrd
+}
+menuentry "@TITLE@ (failsafe)" {
+	linux /boot/vmlinuz failsafe=true @EFI_ROOTPART@ @CMDLINE@ noinitrd
+}

From 317bb3e99c4ad67e6e5680d0fbf03d65294aac2f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=9D=8E=E5=9B=BD?= <uxgood.org@gmail.com>
Date: Tue, 24 Mar 2020 18:01:39 +0800
Subject: [PATCH 7/8] grub2: fix path
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: 李国 <uxgood.org@gmail.com>
---
 package/boot/grub2/grub2/Makefile | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/package/boot/grub2/grub2/Makefile b/package/boot/grub2/grub2/Makefile
index 7126beab4cf..3302838d719 100644
--- a/package/boot/grub2/grub2/Makefile
+++ b/package/boot/grub2/grub2/Makefile
@@ -44,7 +44,7 @@ define Host/Install
 		-d $(STAGING_DIR_HOST)/lib/grub/i386-pc \
 		-p /boot/grub \
 		-O i386-pc \
-		-c ./files/grub-early.cfg \
+		-c ../files/grub-early.cfg \
 		-o $(STAGING_DIR_HOST)/lib/grub/grub2-generic/core.img \
 		at_keyboard biosdisk boot chain configfile ext2 linux ls part_msdos reboot serial vga
 
@@ -53,7 +53,7 @@ define Host/Install
 		-d $(STAGING_DIR_HOST)/lib/grub/i386-pc \
 		-p /boot/grub \
 		-O i386-pc \
-		-c ./files/grub-early.cfg \
+		-c ../files/grub-early.cfg \
 		-o $(STAGING_DIR_HOST)/lib/grub/grub2-iso/eltorito.img \
 		at_keyboard biosdisk boot chain configfile iso9660 linux ls part_msdos reboot serial vga
 
@@ -62,7 +62,7 @@ define Host/Install
 		-d $(STAGING_DIR_HOST)/lib/grub/i386-pc \
 		-p /boot/grub \
 		-O i386-pc \
-		-c ./files/grub-early.cfg \
+		-c ../files/grub-early.cfg \
 		-o $(STAGING_DIR_HOST)/lib/grub/grub2-legacy/core.img \
 		biosdisk boot chain configfile ext2 linux ls part_msdos reboot serial vga
 endef

From 784fcc94242d146f2ef2c31e292ace8816985d62 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=9D=8E=E5=9B=BD?= <uxgood.org@gmail.com>
Date: Tue, 24 Mar 2020 18:02:57 +0800
Subject: [PATCH 8/8] x86: fix
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: 李国 <uxgood.org@gmail.com>
---
 target/linux/x86/image/Makefile | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/target/linux/x86/image/Makefile b/target/linux/x86/image/Makefile
index efb0b1cff99..ff964cde8ab 100644
--- a/target/linux/x86/image/Makefile
+++ b/target/linux/x86/image/Makefile
@@ -115,7 +115,7 @@ define Device/Default
   else
     IMAGES := combined.img
   endif
-  ifeq $(CONFIG_EFI_IMAGES)
+  ifeq ($(CONFIG_EFI_IMAGES),y)
     ifeq ($(CONFIG_TARGET_IMAGES_GZIP),y)
       IMAGES += combined-efi.img.gz
     else
@@ -134,7 +134,7 @@ define Device/Default
   ifeq ($(CONFIG_VMDK_IMAGES),y)
     IMAGES += combined.vmdk
   endif
-  ifeq $(CONFIG_EFI_IMAGES)
+  ifeq ($(CONFIG_EFI_IMAGES),y)
     ifeq ($(CONFIG_ISO_IMAGES),y)
       ARTIFACTS += image-efi.iso
     endif
